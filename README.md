## Build

- Install dependencies (C++17 toolchain, CMake, zlib, pthreads).
- From repo root run:
    - `cmake -S . -B build`
    - `cmake --build build`
    - This builds libschedrt.so, the runner sched_runner, and the shared app plugins (libdemo_dash_app.so, libradar_correlator_app.so).

## Runner usage (sched_runner)

- `--app-lib=PATH` (required) shared object implementing app_initialize/app_run.
- `--backend={auto|cpu|fpga}` choose scheduler backend preference.
- `--cpu-workers=N` number of worker threads (default = hardware concurrency).
- `--preload-threshold=N` how many ready tasks trigger overlay preload (default 3).
- `--bitstream-dir=DIR` directory plugins use to resolve <app>_partial.bit.
- `--fpga-manager=PATH` sysfs path to write partial bitstreams (defaults to /sys/class/fpga_manager/fpga0/firmware).
- `--fpga-real/--fpga-mock` whether FpgaSlotAccelerator actually writes to the manager or stays mock.
- everything after -- is passed verbatim to the plugin as its own arguments (e.g., --input=...).

## DASH plugin flags (libdemo_dash_app.so)

- `--overlay=name[:count]` add overlay slots (default zip:2, fft:1).
- `--cpu-workers, --preload-threshold, --fpga-manager, --fpga-real/--fpga-mock, --bitstream-dir` as above.

## Radar correlator plugin flags (libradar_correlator_app.so)

- `--input=DIR` override where time_input.txt/received_input.txt live (default searches near executable).

## Bitstream placeholders

- `bitstreams/zip_partial.bit, bitstreams/fft_partial.bit, bitstreams/cpu_partial.bit` are still dummy files; replace them with your Vitis bitstreams once available and point --bitstream-dir at that directory.
- For the current Pynq shell bring-up we vendor the real images produced by the `fft_fir_reconfigurable` Vivado project:
  - `bitstreams/static_wrapper.bit` plus the Linux-ready `bitstreams/static_wrapper.bin`.
  - `bitstreams/fft_passthrough_partial.bit` plus `bitstreams/fft_passthrough_partial.bin`.
  The `.bin` variants are generated by stripping the `.bit` header (so `fpga_manager` can load them from `/lib/firmware`), and they work with the `fpga_static_probe` command shown below.
- To convert any other `.bit` into a `.bin`, run `./scripts/bit_to_bin.py path/to/input.bit path/to/output.bin`. The script scans for the payload tag in the `.bit` file and writes the raw bitstream bytes that Linux expects.

## FPGA static probe utility

`fpga_static_probe` is a stand‑alone tool that stages bitstreams into `/lib/firmware`, toggles an optional PR decoupler GPIO, inspects MMIO regions, and can drive a simple AXI‑DMA loopback through `udmabuf` for bring‑up on the Pynq board.

Example:

```
sudo ./build/fpga_static_probe \
  --trace-all \
  --fpga-real \
  --static-bitstream=bitstreams/static_wrapper.bin \
  --overlay=fft_passthrough:bitstreams/fft_passthrough_partial.bin \
  --mmio-probe=dma:0x40400000:0x1000 \
  --mmio-probe-offset=dma:0x0 \
  --mmio-probe-offset=dma:0x4 \
  --mmio-probe-offset=dma:0x28 \
  --run-loopback \
  --udmabuf=udmabuf0 \
  --dma-device=/dev/axi_dma_regs \
  --bytes=65536 \
  --fpga-manager=/sys/class/fpga_manager/fpga0/firmware \
  --fpga-pr-gpio=569 \
  --fpga-pr-gpio-delay-ms=10000
```

Key flags:

- `--static-bitstream` plus `--overlay=name:bit` select the shell and partial images to stage and load through the Linux FPGA manager.
- `--fpga-real/--fpga-mock`, `--fpga-manager`, `--firmware-dir`, and `--fpga-pr-gpio` control how the manager write and optional PR decoupler GPIO behave.
- `--mmio-probe=name:addr:size` with optional `--mmio-probe-offset=name:offset` lets you dump register snapshots via `/dev/mem`.
- `--run-loopback`, `--udmabuf`, `--dma-device`, and `--bytes` enable the AXI‑DMA loopback test; optionally override `--dma-map-size`, `--dma-mmio-region`, and `--loopback-timeout-ms`.
